pragma solidity ^0.4.24;

contract Baccarat2 {
	uint16 private constant MAX_CARDS = (260);

    uint8[MAX_CARDS] private pokers = [
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,

		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,
		
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,

		
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,

		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
/*
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,

		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,

		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
	   */
	];

	uint256 private seed;
	uint256 private randomCounter = 0;
	address private owner;
	mapping(uint256 => uint8[]) private cards;

	event LogGetOneCard(uint256 randomNum, uint256 index, uint256 maxLoop);
    
	modifier onlyOwner {
	    require(
			owner == msg.sender,
			"Only owner can call this function."
		);
		_;
	}

	modifier cardsRemainder(uint256 _roomId) {
	    require(
		   cards[_roomId].length >= 1,
		   "cards not enought." 
		);
		_;
	}

	constructor() public {
	    owner = msg.sender;
	}

	function shuffle(uint256 _roomId) 
	    public
        onlyOwner	
		returns (bool)
	{
        cards[_roomId] = pokers;	
		return true;
	}

	//发牌
	function dealCard(uint256 _roomId) 
	    public 
		onlyOwner
	{
		uint256 local_counter = 0;
		uint8[] memory local_card = new uint8[](4);
        for(uint256 i=0; i<4; i++) {
	        local_card[i] = getOneCard(_roomId, local_counter);        	
			local_counter += 1;
		}	
	}

	//随机抽取一张牌
    function getOneCard(uint256 _roomId, uint256 _counter) 
	    internal 
		cardsRemainder(_roomId) 
		returns (uint8) 
	{
        uint8 local_card;
        //只剩一张牌了
		if (cards[_roomId].length == 1) {
	        local_card = cards[_roomId][0];    	
			shuffle(_roomId);
			return local_card;
		}

		uint256 local_upper = cards[_roomId].length;
		uint256 local_randomNum = 0;
		uint256 local_seed = 0;

		while(local_randomNum == 0) {
	        local_randomNum = random(local_upper, _counter, local_seed);	
			local_seed += 1;
		}

		uint256 local_index = local_randomNum - 1;
		uint256 local_maxLoop = local_upper - 1;

		local_card = cards[_roomId][local_index];

		emit LogGetOneCard(local_randomNum, local_index, local_maxLoop);

		for(uint256 i=local_index; i<local_maxLoop; i++) {
	        cards[_roomId][i] = cards[_roomId][i+1];	
		}

		removeCard(_roomId, local_maxLoop);

		return local_card;
	}	

	//每发一张牌，剩余牌数量减1
	function removeCard(uint256 _roomId, uint256 _index) 
	    private 
		cardsRemainder(_roomId) 
		returns (bool) 
	{
        delete cards[_roomId][_index];	
		cards[_roomId].length--;

		return true;
	}

	//产生一个随机数
	function random(uint256 _upper, uint256 _counter, uint256 _seed)
	    private
        returns (uint256 local_num)
	{
        randomCounter += 1;
		bytes memory local_randSeed = abi.encodePacked(
		    seed,
			blockhash(block.number - 1),
			now,
			block.coinbase,
			block.difficulty,
			randomCounter,
			_counter,
			_seed
		);
        seed = uint256(keccak256(local_randSeed));    	
		local_num = (seed % _upper);
	}
}
