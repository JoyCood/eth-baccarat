pragma solidity 0.4.24;

contract Baccarat3 {
    uint8[][POKERS_NUM] private pokers = [
		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
        ],

		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
        ],
		
		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
        ],
		
		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
        ],

		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
        ],

		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
        ],

		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
        ],

		[
			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,
			0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D
		   
        ]
	];

	uint8 private constant POKERS_NUM = 8;

	mapping(uint256 => uint8[][POKERS_NUM]) public cards;

	event LogShuffle(uint256 shuffle);
	event LogCards(uint8[] card);

	function shuffle(uint256 _roomId) 
	    public 
		returns (bool) 
	{
    	cards[_roomId] = pokers;
		return true;
	}

	function shuffle(uint256 _roomId, uint8 _pokersNum) 
	    public 
		returns (uint8) 
	{
        cards[_roomId][_pokersNum] = pokers[_pokersNum];    	
		return cards[_roomId][_pokersNum][10];
	}

	function dealCard(uint256 _roomId) 
	    public 
		returns (uint8[]) 
	{
		uint8[] memory local_cards = new uint8[](4);
        uint256 local_pokersNum;
		for(uint256 i=0; i<4; i++) {
			local_pokersNum = getPokersNum(_roomId); 
			local_cards[i] = getCard(_roomId, local_pokersNum); 
		}
		emit LogCards(local_cards);
		return local_cards;
	}

	function getCard(uint256 _roomId, uint256 _pokersNum) 
	    private 
		returns(uint8) 
	{
		uint8 local_card;
       
        if(cards[_roomId][_pokersNum].length == 1) {
		    local_card = cards[_roomId][_pokersNum][0];
			removeCard(_roomId, _pokersNum, 0);
			return local_card;
		}
		uint256 local_upper = cards[_roomId][_pokersNum].length;
		uint256 local_randomNum = 0;
		uint256 local_seed = 0;

		while(local_randomNum == 0) {
	        local_randomNum = random(local_upper, local_seed);	
			local_seed += 1;
		}
        
        uint256 local_index = local_randomNum - 1;
        uint256 local_maxLoop = local_upper - 1;		

		local_card = cards[_roomId][_pokersNum][local_index];
        //将后面的牌往前移
		for(uint256 i=local_index; i<local_maxLoop; i++) {
	        cards[_roomId][_pokersNum][i] = cards[_roomId][_pokersNum][i+1];	
		}
        removeCard(_roomId, _pokersNum, local_maxLoop);
		return local_card;
	}

    function removeCard(uint256 _roomId, uint256 _pokersNum, uint256 _index) 
	    private
		returns (bool)
	{
        delete cards[_roomId][_pokersNum][_index];	
		cards[_roomId][_pokersNum].length--;

		return true;
	}

	function getPokersNum(uint256 _roomId) 
	    private 
		returns (uint256) 
	{
        uint256[] memory local_pokers = new uint256[](POKERS_NUM);
        uint256 local_index = 0;

        for(uint256 i=0; i<POKERS_NUM; i++) {
	        if(cards[_roomId][i].length != 0) {
        	    local_pokers[local_index] = i;
				local_index += 1;
			}	
		}        
		if(local_index == 0) {
			shuffle(_roomId);
			local_index = POKERS_NUM;
			//emit LogShuffle(local_index);
		}
		uint256 local_key;
		if(local_index==1) {
		    local_key = 0;
		} else {
		   	local_key = random(local_index-1, 0);
		}
        
		return local_pokers[local_key];
	}

	//产生一个随机数
	function random(uint256 _upper, uint256 _seed)
	    private
		view
        returns (uint256 local_num)
	{
		bytes memory local_randSeed = abi.encodePacked(
			blockhash(block.number - 1),
			now,
			block.coinbase,
			block.difficulty,
			_seed
		);
        uint256 seed = uint256(keccak256(local_randSeed));    	
		local_num = (seed % _upper);
	}

	

}
